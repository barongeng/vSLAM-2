{-|
Module      : Measurement
License     : WTFPL
Maintainer  : Pavel Potocek <pavelpotocek@gmail.com>

This package contains the bulk of the maths involved in the FastSLAM algorithm.
That is, all the EKF stuff is here. The code has been largely generated by
Sagemath. Invariants are checked by the 'TestMeasurement' package.

I have got quite a confidence in the correctness of this code.
-}
module Measurement where

import Numeric.LinearAlgebra
import Numeric.LinearAlgebra.Util ((!))

import InternalMath
import Landmark
import Camera
import Parameters


-- | Initialize a 'Landmark' from a single 'Feature'. 
initialize :: ExactCamera -> Feature -> Landmark
initialize (ExactCamera cpos crot) feature = Landmark
		(fid2lid $ fid feature) 
		(join [cpos, 3 |> [theta, phi, initialRho]])  
		initialCov 
		(descriptor feature)
		1 where
	h = euler2vec (fpos feature)
	(theta, phi) = vec2euler . head.toColumns $ crot <> asColumn h


-- | 6D 'Landmark' mean to a directional (un-normalized) vector in the world-space.
-- The result is independent of the 'Camera' rotation.
measure_g :: Vector Double  -- ^ 3D 'Camera' position
          -> Vector Double  -- ^ 6D 'Landmark' mean
          -> Vector Double  -- ^ 3D ray from the 'Camera' to the 'Landmark'
measure_g camPos f = scale rho (fpos - camPos) + euler2vec (theta, phi) where
	[fpos, tmp] = takesV [3,3] f
	[theta, phi, rho] = toList tmp


-- | 6D Landmark mean to a directional (un-normalized) vector in camera-space.
measure_h :: ExactCamera -> Vector Double -> Vector Double
measure_h (ExactCamera cpos crot) f = head.toColumns $ trans crot <> asColumn (measure_g cpos f)


-- | The projection of the 6D Landmark mean to the theta-phi parametrisation.
measure :: ExactCamera -> Vector Double -> (Double, Double)
measure c f = vec2euler $ measure_h c f


-- | Measurement equation jacobian with respect to the landmark
-- The maths is computed by hand. The whole routine is verified by a monte-carlo 
-- test by the definition of derivative (in 'TestMeasurement' module).
jacobian_l :: ExactCamera -> Vector Double -> Matrix Double
jacobian_l (cam@(ExactCamera cpos crot)) l = fromRows [e1', e2'] where
	[x, y, z, theta, phi, rho] = toList l
	[x_c, y_c, z_c] = toList cpos
	[h_x, h_y, h_z] = toList $ measure_h cam l
	[h_x', h_y', h_z'] = toRows h'
	h' = trans crot <> ((3><6) 
		[ rho,   0,   0,  cos theta * cos phi, -sin theta * sin phi, x - x_c
		,   0, rho,   0,                    0,             -cos phi, y - y_c
		,   0,   0, rho, -sin theta * cos phi, -cos theta * sin phi, z - z_c ])
	
	xxzz = h_x*h_x + h_z*h_z
	e1' = scale (h_z / xxzz) h_x' - scale (h_x / xxzz) h_z'
	e2' = scale (-sqrt xxzz / (xxzz + h_y*h_y)) h_y' +
	      scale (h_y / (xxzz + h_y*h_y) / sqrt xxzz) 
			(scale h_x h_x' + scale h_z h_z')



-- | Measurement equation jacobian with respect to the camera.
-- Optimize: give it a pre-computed camera rotation matrix and its derivatives.
-- All matrices are generated by Sage Mathematics. The surrounding maths is
-- computed by hand. The whole routine is verified by a monte-carlo test
-- by the definition of derivative.
jacobian_c :: GaussianCamera -> Vector Double -> Matrix Double
jacobian_c (GaussianCamera mu _) l_mu = fromRows [e1', e2'] where
	rho = l_mu @> 5
	[c_x, c_y, c_z, alpha, beta, gamma] = toList mu
	
	sa = sin alpha; sb = sin beta; sg = sin gamma;
	ca = cos alpha; cb = cos beta; cg = cos gamma; 
	
	cpos = (3|> [c_x,c_y,c_z])
	crot = (3><3) -- yaw, pitch, roll to a rotation matrix
		[  sa*sb*sg + ca*cg, -cg*sa*sb + ca*sg, -cb*sa
		,            -cb*sg,             cb*cg,    -sb
		, -ca*sb*sg + cg*sa,  ca*cg*sb + sa*sg,  ca*cb ]
		
	[h_x, h_y, h_z] = toList $ measure_h (ExactCamera cpos crot) l_mu
	[h_x', h_y', h_z'] = toRows h'

	dR_da = (3><3)
		[ ca*sb*sg - cg*sa, -ca*cg*sb - sa*sg, -ca*cb
		,                0,                 0,      0
		, sa*sb*sg + ca*cg, -cg*sa*sb + ca*sg, -cb*sa ]
	dR_db = (3><3)
		[ cb*sa*sg, -cb*cg*sa,  sa*sb
		,    sb*sg,    -cg*sb,    -cb
		, -ca*cb*sg, ca*cb*cg, -ca*sb ]
	dR_dg = (3><3)
		[  cg*sa*sb - ca*sg,  sa*sb*sg + ca*cg, 0
		,            -cb*cg,            -cb*sg, 0
		, -ca*cg*sb - sa*sg, -ca*sb*sg + cg*sa, 0 ]

	g' = asColumn $ measure_g cpos l_mu
	h' = (trans crot <> scale (-rho) (ident 3)) ! (trans dR_da <> g') ! (trans dR_db <> g') ! (trans dR_dg <> g')
	
	xxzz = h_x*h_x + h_z*h_z
	e1' = scale (h_z / xxzz) h_x' - scale (h_x / xxzz) h_z'
	e2' = scale (-sqrt xxzz / (xxzz + h_y*h_y)) h_y' +
	      scale (h_y / (xxzz + h_y*h_y) / sqrt xxzz) 
			(scale h_x h_x' + scale h_z h_z')

